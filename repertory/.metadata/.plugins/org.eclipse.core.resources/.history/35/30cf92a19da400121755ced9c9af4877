/*
 * rep.h
 *
 *  Created on: 2013-4-10
 *      Author: root
 */

#ifndef REP_H_
#define REP_H_

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include<fcntl.h>
#include<string.h>
#include<stdio.h>
#include<stdlib.h>

#include <unistd.h>
#include <sstream>
#include <string>
#include <iostream>
#include <fstream>

#include "errno.h"
#include "map"
#include "vector"
#include "GlobalHelper.h"
#define DEBUG
using namespace std;

namespace poseidon {
struct rep_command {
	int commd_id;
	int slave_id;
	vector<string> task_id;
	unsigned long content_size;
	int last_task_status;
};
struct req_task {
	int sleep_time;

	vector<string> task_id;

	int slave_id;
	int cmd_id;

	string store_ip;
	int store_port;

	string request_ip;
	int request_port;

	string urls;

	vector<string> urls_vec;
	vector<string> urls_http_req;
	vector<string> urls_sites;
	map<string, string> response_cmd_map;
	vector<string> new_version_url;
	int version;

};
const string s_socket = "socket";

class rep {
	GlobalHelper *gh;
public:
	int master_port;
	vector<string> master_ip;
	rep() {

		gh = new GlobalHelper();
		config_rep();
	}

	virtual ~rep();
	void config_rep() {
		map<string, string> config_map1;
		gh->read_config(gh->REP_CONF, config_map1);
		this->master_port = atoi((config_map1["master_port"]).c_str());
		this->master_ip.push_back(config_map1["master_ip"]);

	}
	int service() {

		//1 init variable
		int socketfd;
		int new_fd;
		struct sockaddr_in client_addr;
		struct sockaddr_in local_addr;
		char request_buff[gh->TASK_BUF_SIZE];

		//2 create socket
		if ((socketfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
			perror("socket fd create fail...");
			return -1;
		}

		//3 prepare listen access point
		gh->init_address(&local_addr, PF_INET, this->master_port, INADDR_ANY);

		//4 bind and listen
		if (-1
				== bind(socketfd, (struct sockaddr*) (&local_addr),
						sizeof(struct sockaddr))) {
			perror("socket fd connet fail...");
			return -1;
		}
		if (listen(socketfd, 128) == -1) {
			perror("socket fd listen fail...");
			return -1;
		}
		cout << "rep:waiting for your connection!" << endl;

		//5  service is receive cmd and response cmd
		socklen_t client_addr_size;
		while (1) {
			client_addr_size = sizeof(client_addr);
			//5.1 accept
			if ((new_fd = accept(socketfd, (struct sockaddr*) (&client_addr),
					&client_addr_size)) == -1) {
				perror("socket new_fd accept fail...");
				return -1;
			}
			string str_log = "conntection from:";
			str_log += inet_ntoa(client_addr.sin_addr);
			gh->log2(str_log, "socket");

			//5.2   accept until \f
			ssize_t read_count;
			while (1) {
				bzero(request_buff, sizeof request_buff);
				read_count = read(new_fd, request_buff, sizeof request_buff);
				if (read_count == -1) {
					perror("socket fd read fail...");
					break;
				}
				if (gh->tail_with_feature(request_buff, read_count, "\f")) {
					break;
					//TODO:: extract a function :is revice OK?
				}
			}
			request_buff[read_count] = '\0';

			string cog_str1 = "request is:";
			//cout<<(cog_str1 + request_buff)<<endl;
			gh->log2(cog_str1 + request_buff, "socket");

			//5.3 hand request
			string request_str = request_buff;
			struct rep_command req_cmd;

			if (!is_req_store(request_str, req_cmd)) {
				break;
			}
			gh->log2("5.4 write to request:\f ", "socket");
			//5.4 write to request
			string respose_content = "\f";
			int write_result = write(new_fd, respose_content.c_str(),
					strlen(respose_content.c_str()));
			if (write_result < 0) {
				perror("socket fd write fail...");
			}

			//5.5 accept the real content with gzip
			string filename = "./pages_gzip/" + req_cmd.task_id.at(0)
					+ ".tar.gz";

			//	gh->log2("5.4 write to request:\f ","task");
			gh->log2("5.5 filename:" + filename, "task");
			int fd = open(filename.c_str(), O_CREAT | O_WRONLY | O_TRUNC);
			unsigned long total = 0;
//5.6 read  gzeip page
			while (1) {
				bzero(request_buff, sizeof request_buff);
				read_count = read(new_fd, request_buff, sizeof request_buff);
				if (read_count == -1) {
					perror("socket fd read fail...");
					break;
				}
				request_buff[read_count] = '\0';
				//write to local file
				write(fd, request_buff, read_count);
				total += read_count;
				//		gh->log("*total:" + total);
				if (total == req_cmd.content_size) {
					break;
				}
				if (read_count == 0) {
					gh->log("receive eof ,so total is bad ");
					break;
				}

			} //end accept data
			close(fd);
			gh->log("5.7 ok,file saved! ");
		} //end step 5

		return 0;
	}
//===========
	bool is_req_store(string request_str, struct rep_command& req_cmd) {
		bool is_store;
		//==============================================
		//1  request string struct command
		//==============================================
		map<string, string> req_cmd_map;
		gh->command_str_to_map(request_str, &req_cmd_map);
		//struct command req_cmd;
		req_cmd.commd_id = atoi(req_cmd_map["commd_id"].c_str());
		req_cmd.task_id.push_back(req_cmd_map["task_id"]);
		req_cmd.slave_id = atoi(req_cmd_map["slave_id"].c_str());
		req_cmd.content_size = strtoul(req_cmd_map["content_size"].c_str(),
				NULL, 0);
		//req_cmd_map["pagecontent"]
		cout << "request_command:" << req_cmd.commd_id << endl;
		//==============================================
		//3 switch command type
		//==============================================
		map<string, string> response_cmd_map;
		switch (req_cmd.commd_id) {
		case 5: //slave to rep
			//store_message(request_str);
			is_store = 1;
			break;
		default:
			is_store = 0;
			break;
		}

		return is_store;
	}
	//=========
#define BUFSIZE 1449
	bool request_task(req_task *mytask, string& str_cmd) {
		//1 init variable
		int socketfd;
		struct sockaddr_in dest_addr;
		char read_buf[BUFSIZE];
		bzero(&read_buf, sizeof read_buf);
		bool req_seccess = 0;
		string log_str;
		while (1) {

			//2 create socket
			if ((socketfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
				log_str = "socket fd create fail...";
				log_str += strerror(errno);
				gh->log2(log_str, s_socket); //perror("socket fd create fail...");

				break;
			}

			//3 prepare server address
			gh->init_address(&dest_addr, PF_INET, this->master_port,
					this->master_ip[0]);

			//4 connect to server
			if (-1
					== connect(socketfd, (struct sockaddr*) &dest_addr,
							sizeof(struct sockaddr))) {
				log_str = "socket fd connect fail...";
				log_str += strerror(errno);
				gh->log2(log_str, s_socket);
				break;
			}
			gh->log2(
					"Connect ot:" + this->master_ip[0] + ":"
							+ gh->num2str(this->master_port), s_socket);

			//5 write to master
			int bytes_count;
			this->cmd_req_2send = this->init_request_cmd_str(); //last_task_status
			int write_result = write(socketfd, this->cmd_req_2send.c_str(),
					strlen(this->cmd_req_2send.c_str()));
			if (write_result == -1) {
				log_str = "socket fd write fail...";
				log_str += strerror(errno);
				gh->log2(log_str, s_socket); //perror
				break; //continue;
			}
			gh->log2("write:" + this->cmd_req_2send, s_socket);

			//6 read
			int total = 0;
			string t_str_cmd = "";
			while ((bytes_count = read(socketfd, read_buf, READ_BUFF_SIZE)) > 0) {
				total += bytes_count;
				if (bytes_count == 0) {
					break;
				}
				if (gh->tail_with_feature(read_buf, bytes_count, "\f")) {
					break;
				}
				read_buf[bytes_count] = '\0';
				t_str_cmd += read_buf;
			}
			req_seccess = 1;
			break;
		}
		//}
		//7 clear socket
		close(socketfd);
		//8  init task
		//	cout << "receive:" << read_buf << endl;
		str_cmd = read_buf;
		//	gh->log(str_cmd);
		return req_seccess;

	}

	//=============
};

}
#endif /* REP_H_ */
