/*
 * GlobalHelper.h
 *
 *  Created on: 2013-4-4
 *      Author: root
 */

#ifndef GLOBALHELPER_H_
#define GLOBALHELPER_H_

#include<fcntl.h>
#include<string.h>
#include<stdio.h>
#include<stdlib.h>
#include <vector>
#include <iostream>
#include <numeric>
#include <algorithm>
#include <sstream>
#include <string>
#include <iostream>
#include <sys/time.h>
#include "map"
#include <iostream>     // std::cout
#include <algorithm>    // std::find_if
#include <vector>       // std::vector
using namespace std;

#define DEBUG
#define LOG
namespace poseidon {

class GlobalHelper {
private:
//	clock_t clockBegin;
//	clock_t clockEnd;
	struct timeval start, stop, diff;
	int tim_subtract(struct timeval *result, struct timeval *start,
			struct timeval *stop) {
		if (start->tv_sec > stop->tv_sec)
			return -1;
		if ((start->tv_sec == stop->tv_sec) && (start->tv_usec > stop->tv_usec))
			return -1;
		result->tv_sec = (stop->tv_sec - start->tv_sec);
		result->tv_usec = (stop->tv_usec - start->tv_usec);
		if (result->tv_usec < 0) {
			result->tv_sec--;
			result->tv_usec += 1000000;
		}
		return 0;
	}
public:
	GlobalHelper();
	virtual ~GlobalHelper();

	void timing_begin() {
		gettimeofday(&start, 0);
	}
	void timing_end() {
		gettimeofday(&stop, 0);
	}
	string cast_time() {
		tim_subtract(&diff, &start, &stop);
		return ld2str(diff.tv_sec) + "." + ld2str(diff.tv_usec);
	}
	void time_test2() {
		timing_begin();
		usleep(1);
		timing_end();
		cout << "cast_time" << cast_time() << "秒" << endl;
	}
//num to string
	string num2str(int i) {
		stringstream ss;
		ss << i;
		return ss.str();
	}
	string ld2str(long int i) {
		stringstream ss;
		ss << i;
		return ss.str();
	}

	//实现string到unsigned int的转换
	unsigned int string_to_unsigned_int(string str) {
		unsigned int result(0); //最大可表示值为4294967296（=2‘32-1）
		//从字符串首位读取到末位（下标由0到str.size() - 1）
		for (int i = str.size() - 1; i >= 0; i--) {
			unsigned int temp(0), k = str.size() - i - 1;
			//判断是否为数字
			if (isdigit(str[i])) {
				//求出数字与零相对位置
				temp = str[i] - '0';
				while (k--)
					temp *= 10;
				result += temp;
			} else {
				break;
			}
			//exit(-1);

		}
		return result;
	}

	//unit is byte
	int file_size(string filename) {
		FILE *stream;
		stream = fopen(filename.c_str(), "r");
		fseek(stream, 0L, SEEK_END);
		long length = ftell(stream);
		fclose(stream);
		return length;
	}
	void string_contain_test() {
		string s1 = "HTTP/1.1 200 OK\r\n"
				"Cache-Control: max-age=86400\r\n"
				"Date: Thu, 04 Apr 2013 10:34:04 GMT\r\n"
				"Content-Length: 20035\r\n"
				"Content-Type: text/html\r\n";

		string s2;
		if (string_contain(s1, "Content-Length", &s2)) {
			cout << s2 << endl;
		}
		string::size_type len;
		if (Content_length(s1, &len)) {
			cout << len << endl;
		}

	}
	bool Content_length(string s1, string::size_type *length) {
		string s2;
		if (string_contain(s1, "Content-Length", &s2)) {
			*length = this->string_to_unsigned_int(s2);
			return true;
		}
		return false;
	}
	bool string_contain(string str, string key, string *result) {
		unsigned int pos;
		unsigned int pos1;
		unsigned int pos2;
//STRING.FIND 查找，找到第一个取其：后\r\n 前的值。
		if ((pos = str.find(key, 0)) == string::npos) {
			return false;
		}
		if ((pos1 = str.find(":", pos)) == string::npos) {
			return false;
		}
		pos1++;
		if ((pos2 = str.find("\r", pos)) == string::npos) {
			return false;
		}
		cout << "pos=" << pos << " pos1=" << pos1 << " pos2=" << pos2 << endl;
		if (pos1 > pos2) {
			return false;
		}
		*result = str.substr(pos1, pos2 - pos1);
		return true;
	}

//是否以给定字符串结尾
	bool tail_with_feature(char* buf, int count, const char* feature) {

		int feature_len = strlen(feature);

		if (count < feature_len || 0 >= feature_len) {
			return false;
		}
		for (int j = 0; j < feature_len; ++j) {
			if (buf[count - j - 1] != feature[feature_len - j - 1]) {
				return false;
			}
		}
		return true;
	}

	bool split_char(char c) {
		return c == ':';
	}
	bool not_split_char(char c) {
		return c != ':';
	}
	//for test
	bool IsOdd(int i) {
		return ((i % 2) == 1);
	}
	//
	//按行分割
	void split_line(string in, vector<string> *vec) {
		istringstream ss(in);
		string t;
		while (ss >> t) {
			//	cout << t << endl;
			vec->push_back(t);
		}
	}
	//以 为分隔符 只能取前2个
	//str=slave_id:1
	void split_by_split_char(string str, vector<string> *vec, char split_char) {
		string::size_type pos = 0;
		pos = str.find_first_of(':', pos);
		vec->push_back(str.substr(0, pos));
		vec->push_back(str.substr(pos + 1, str.size()));
	}
	//以 为分隔符 尝试使用 算法模板 失败。待调试
	void split_4alg(string str, vector<string> *vec, char split_char) {
		typedef string::const_iterator iter;
		iter i = str.begin();
		while (i != str.end()) {
			//i =
			//std::find_if(i, str.end(), not_split_char);
		}
		//string t;
		//vec->push_back(t);
		std::vector<int> myvector;
		myvector.push_back(10);
		//typedef bool (poseidon::GlobalHelper::*p1)(int);
		//p1 cfp = &poseidon::GlobalHelper::IsOdd;
		//	bool (*IsOddfun)(int); //bool (poseidon::GlobalHelper::)(int)
		//	std::vector<int>::iterator it = std::find_if(myvector.begin(),
		//			myvector.end(), cfp);
		//std::cout << "The first odd value is " << *it << '\n';

	}

//以"\r "为分隔符
	bool split_line_test() {
		vector<string> *vec = new vector<string>();
		string command1 = "commd_id:1\r\n"
				"slave_id:1\r\n"
				"application_version:1\r\n"
				"\f";
		split_line(command1, vec);
		bool res = false;
		string s1 = "commd_id:1";
		res = (s1 == vec->at(0));
		if (!res) {
			cout << res << endl;
			return res;
		}
		vector<string> *vec2 = new vector<string>();
		split_by_split_char(s1, vec2, ':');
		res = (s1 == vec2->at(0));
		cout << vec2->at(0) << endl;
		cout << vec2->at(1) << endl;
		return res;

	}
	//==================================
	//无限分割入VEC
	void split(const string& src, const string& separator,
			vector<string>& dest) {
		string str = src;
		string substring;
		string::size_type start = 0, index;
		do {
			index = str.find_first_of(separator, start);
			if (index != string::npos) {
				substring = str.substr(start, index - start);
				dest.push_back(substring);
				start = str.find_first_not_of(separator, index);
				if (start == string::npos)
					return;
			}
		} while (index != string::npos);
		//the last token
		substring = str.substr(start);
		dest.push_back(substring);
	}
	bool split_test() {
		vector<string> str_vec;
		string s1 = "1#www.baidu.com#2.com#";
		const string s2 = "#";

		split(s1, "#", str_vec);
		cout << str_vec.at(0) << endl;
		cout << str_vec.at(1) << endl;
		cout << str_vec.at(2) << endl;
		cout << "SIZE:" << str_vec.size() << endl;
		return 1;
		//split(s1, &s2, &str_vec);
	}

	//==================================
	void command_str_to_map(string command1, map<string, string> *command_map) {
		vector<string> *vec = new vector<string>();
		vector<string>::iterator it1;
		split_line(command1, vec);
		for (it1 = vec->begin(); it1 != vec->end(); ++it1) {
			vector<string> vec2;
			split_by_split_char(*it1, &vec2, ':');
			string key = vec2.at(0);
			string value = vec2.at(1);
			(*command_map)[key] = value;
		}
	}
	//以"\r "为分隔符
	bool command_str_to_map_test() {

		map<string, string> command_map;
		string command1 = "commd_id:1\r\n"
				"slave_id:1\r\n"
				"application_version:1\r\n"
				"\f";

		command_str_to_map(command1, &command_map);

		for (map<string, string>::iterator it2 = command_map.begin();
				it2 != command_map.end(); ++it2) {
			std::cout << it2->first << " => " << it2->second << '\n';
		}
		//cout << "split_line_test:" << (commd_id == 1) << endl;

		return 1;
	}
	//==========================================
	string replace(string str, string new_str, string special_char) {
		string::size_type pos(0);
		pos = str.find_first_of(special_char);
		str = str.replace(pos, 1, "");
		return str.insert(pos, new_str);
	}
	void replace_test() {
		string s1 = "GET /question/#.html Host:@\r\n";
		string s2 = replace(s1, "123", "#");
		cout << "s2:" << s2 << endl;
		string s3 = replace(s2, "345", "@");
		cout << "s3:" << s3 << endl;

	}
	string get_sitename(string url) {
		string::size_type pos1; //  pos of  '/'
		pos1 = url.find_first_of('/', 0);
		string sitename = url.substr(0, pos1);
		return sitename;
	}
	string convert_url_to_http_req(string url) {
		string req =
				"GET # HTTP/1.1\r\n"
						"Host: @\r\n"
						"Connection: close\r\n"
						"Cache-Control: max-age=0\r\n"
						"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
						"User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31\r\n"
						//		"Accept-Encoding: gzip,deflate,sdch\r\n"
						"Accept-Language: zh-CN,zh;q=0.8\r\n"
						"Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3\r\n"
						"\r\n";
		string::size_type pos1; //  pos of  '/'
		pos1 = url.find_first_of('/', 0);
		string sitename = url.substr(0, pos1);
		string urlbody = url.substr(pos1);

		req = replace(req, urlbody, "#");
		req = replace(req, sitename, "@");
		//cout << "sitename:" << sitename << endl;
		//	cout << "urlbody:" << urlbody << endl;
		return req;
	}
	bool convert_url_to_http_req_test() {
		string url = "wx.114chn.com/m/web/shop/index.aspx";
		cout << "url:" << url << endl;
		string http_req = convert_url_to_http_req(url);
		cout << "http_req:" << http_req << endl;
		return 1;
	}
	void log(string content) {
#ifdef DEBUG
		cout << content << endl;
#endif

#ifdef LOG
		struct tm *newtime;
		char tmpbuf[128];
		time_t lt1;
		time(&lt1);
		newtime = localtime(&lt1);
		strftime(tmpbuf, 128, "%Y%m%d", newtime);
		string time_str;
		string filename = "./log/slave#.txt";
		filename = replace(filename, "#", time_str);
		ofstream outfile(filename, ios::app);
		outfile << content;
		outfile.close();
#endif

	}
	//==========================================
}
;

}
#endif /* GLOBALHELPER_H_ */
